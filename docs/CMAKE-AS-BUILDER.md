# CMake as Builder: Pure CMake-Driven Nix Builds

## Vision

Instead of using bash as the orchestrator and CMake as a tool, **make CMake the builder itself**. This aligns with the pure toolchain philosophy: let the build system drive the build, not shell scripts.

## Current Approach (Bash-Driven)

```
┌─────────────────────────────────────────┐
│  stdenv.mkDerivation                    │
│  (bash orchestrates everything)         │
└────────────────┬────────────────────────┘
                 │
    ┌────────────┴────────────┬─────────────────┐
    ▼                         ▼                 ▼
┌──────────┐          ┌──────────────┐  ┌──────────────┐
│ unpack   │          │ configure    │  │ build        │
│ (tar)    │          │ (cmake)      │  │ (make/ninja) │
└──────────┘          └──────────────┘  └──────────────┘
```

**Problems:**
- Bash is in control, CMake is just a tool
- Hook ordering is implicit and fragile
- Platform-specific shell scripts
- "The tail wags the dog"

## Proposed Approach (CMake-Driven)

```
┌─────────────────────────────────────────┐
│  builtins.derivation                    │
│  builder = cmake                        │
│  args = ["--workflow" "--preset" "nix"] │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│  CMake Workflow Preset                  │
│  (CMake orchestrates everything)        │
└────────────────┬────────────────────────┘
                 │
    ┌────────────┴────────────┬─────────────────┐
    ▼                         ▼                 ▼
┌──────────┐          ┌──────────────┐  ┌──────────────┐
│ unpack   │          │ configure    │  │ build        │
│ (cmake)  │          │ (cmake)      │  │ (cmake)      │
└──────────┘          └──────────────┘  └──────────────┘
```

**Advantages:**
- CMake drives the entire build
- Declarative workflow (JSON presets)
- Platform-independent (cmake -E commands)
- Explicit ordering and dependencies
- True "build system as builder"

## Key Insight: cmake -E Commands

CMake provides **platform-independent** shell-like commands via `cmake -E`:

### File Operations
```bash
# Copy files
cmake -E copy source.txt dest.txt
cmake -E copy_directory src/ dest/
cmake -E copy_if_different file1 file2

# Create/remove directories
cmake -E make_directory path/to/dir
cmake -E rm -rf path/to/dir

# Symlinks
cmake -E create_symlink target linkname
```

### Archive Operations (THE KEY!)
```bash
# Extract tarballs - no tar command needed!
cmake -E tar xzf archive.tar.gz
cmake -E tar xjf archive.tar.bz2
cmake -E tar xJf archive.tar.xz
cmake -E tar xf archive.zip

# Create archives
cmake -E tar czf output.tar.gz files...
```

### Checksums
```bash
cmake -E sha256sum file1 file2 file3
cmake -E md5sum file
```

### Environment and Execution
```bash
# Run in modified environment
cmake -E env VAR=value command args...

# Change directory and run
cmake -E chdir /path/to/dir command
```

### Utilities
```bash
# Touch files
cmake -E touch file.txt

# Echo (for scripting)
cmake -E echo "message"

# Sleep
cmake -E sleep 5

# Time commands
cmake -E time command args...
```

**This means we can do the entire build with just CMake!**

## Architecture

### 1. CMake Presets-Driven Build

#### CMakePresets.json (Generated by Nix)

```json
{
  "version": 6,
  "configurePresets": [
    {
      "name": "nix-build",
      "displayName": "Nix Build Configuration",
      "description": "Configuration generated by nix-cmake",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build",
      "toolchainFile": "$env{NIX_CMAKE_TOOLCHAIN_FILE}",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_INSTALL_PREFIX": "$env{out}",
        "CMAKE_PREFIX_PATH": "$env{NIX_CMAKE_PREFIX_PATH}",
        "BUILD_TESTING": false
      },
      "environment": {
        "NIX_BUILD": "1"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "nix-build",
      "displayName": "Nix Build",
      "configurePreset": "nix-build",
      "jobs": "$env{NIX_BUILD_CORES}"
    }
  ],
  "testPresets": [
    {
      "name": "nix-build",
      "displayName": "Nix Tests",
      "configurePreset": "nix-build",
      "execution": {
        "jobs": "$env{NIX_BUILD_CORES}"
      }
    }
  ],
  "packagePresets": [
    {
      "name": "nix-build",
      "displayName": "Nix Package",
      "configurePreset": "nix-build",
      "generators": ["TGZ"]
    }
  ],
  "workflowPresets": [
    {
      "name": "nix-build",
      "displayName": "Nix Build Workflow",
      "description": "Complete build workflow for Nix",
      "steps": [
        {
          "type": "configure",
          "name": "nix-build"
        },
        {
          "type": "build",
          "name": "nix-build"
        },
        {
          "type": "test",
          "name": "nix-build"
        }
      ]
    }
  ]
}
```

### 2. Pure CMake Builder

```nix
# lib/cmake-builder.nix
{ lib, cmake, ninja, writeText, writeScript }:

{ src
, pname
, version
, preset ? "nix-build"
, toolchainFile
, dependencies ? {}
, cmakeFlags ? {}
, doCheck ? false
, ...
}@args:

let
  # Generate CMakePresets.json from Nix configuration
  presetsFile = writeText "CMakePresets.json" (builtins.toJSON {
    version = 6;

    configurePresets = [{
      name = preset;
      generator = "Ninja";
      binaryDir = "\${sourceDir}/build";
      toolchainFile = toString toolchainFile;

      cacheVariables = {
        CMAKE_BUILD_TYPE = "Release";
        CMAKE_INSTALL_PREFIX = "$env{out}";
        CMAKE_PREFIX_PATH = lib.concatStringsSep ";" (lib.attrValues dependencies);
      } // cmakeFlags;
    }];

    buildPresets = [{
      name = preset;
      configurePreset = preset;
      jobs = "$env{NIX_BUILD_CORES}";
    }];

    testPresets = lib.optional doCheck {
      name = preset;
      configurePreset = preset;
    };

    workflowPresets = [{
      name = preset;
      steps = [
        { type = "configure"; name = preset; }
        { type = "build"; name = preset; }
      ] ++ lib.optional doCheck { type = "test"; name = preset; };
    }];
  });

  # Pure CMake builder script
  # Uses only cmake -E commands for portability
  builder = writeScript "cmake-builder.sh" ''
    #!${cmake}/bin/cmake -P
    # Pure CMake script - no bash!

    # Extract source archive using cmake -E tar
    execute_process(
      COMMAND ${cmake}/bin/cmake -E tar xzf $ENV{src}
      WORKING_DIRECTORY $ENV{TMPDIR}
      RESULT_VARIABLE result
    )
    if(result)
      message(FATAL_ERROR "Failed to extract source")
    endif()

    # Find the extracted directory
    file(GLOB source_dirs "$ENV{TMPDIR}/*")
    list(GET source_dirs 0 source_dir)

    # Copy our generated presets
    execute_process(
      COMMAND ${cmake}/bin/cmake -E copy
        ${presetsFile}
        ''${source_dir}/CMakePresets.json
    )

    # Run the workflow
    execute_process(
      COMMAND ${cmake}/bin/cmake
        --workflow
        --preset ${preset}
      WORKING_DIRECTORY ''${source_dir}
      RESULT_VARIABLE result
    )
    if(result)
      message(FATAL_ERROR "Workflow failed")
    endif()

    # Install to $out (CMake already does this via CMAKE_INSTALL_PREFIX)
    # But we can verify:
    if(NOT EXISTS "$ENV{out}")
      message(FATAL_ERROR "Installation failed - $ENV{out} not created")
    endif()
  '';

in builtins.derivation (args // {
  name = "${pname}-${version}";

  # CMake IS the builder!
  builder = "${cmake}/bin/cmake";
  args = [ "-P" builder ];

  # Minimal PATH - just need cmake and ninja
  PATH = lib.makeBinPath [ cmake ninja ];

  # Pass through environment
  inherit src;
  out = placeholder "out";
  NIX_BUILD_CORES = builtins.toString (args.cores or 1);
  NIX_CMAKE_TOOLCHAIN_FILE = toString toolchainFile;
})
```

### 3. Alternative: Hybrid Approach (More Practical)

Keep bash for unpacking/patching, but use CMake workflow for everything else:

```nix
# lib/cmake-builder-hybrid.nix
{ lib, stdenv, cmake, ninja }:

{ src
, pname
, version
, preset ? "nix-build"
, toolchainFile
, dependencies ? {}
, cmakeFlags ? {}
, ...
}@args:

stdenv.mkDerivation (args // {
  inherit pname version src;

  nativeBuildInputs = [ cmake ninja ];

  # Standard unpack/patch phases
  # This handles tarballs, git repos, patching, etc.
  phases = [ "unpackPhase" "patchPhase" "buildPhase" "installPhase" ];

  # Generate CMakePresets.json during patch phase
  postPatch = ''
    cat > CMakePresets.json <<EOF
    ${builtins.toJSON {
      version = 6;
      configurePresets = [{
        name = preset;
        generator = "Ninja";
        binaryDir = "build";
        toolchainFile = toString toolchainFile;
        cacheVariables = {
          CMAKE_INSTALL_PREFIX = placeholder "out";
          CMAKE_PREFIX_PATH = lib.concatStringsSep ";" (lib.attrValues dependencies);
        } // cmakeFlags;
      }];
      workflowPresets = [{
        name = preset;
        steps = [
          { type = "configure"; name = preset; }
          { type = "build"; name = preset; }
        ];
      }];
    }}
    EOF
  '';

  # Build phase is JUST cmake workflow
  # No manual configure/make/install steps
  buildPhase = ''
    runHook preBuild

    cmake --workflow --preset ${preset}

    runHook postBuild
  '';

  # Install phase is no-op - CMake workflow already installed
  installPhase = ''
    runHook preInstall

    # CMake already installed to $out via CMAKE_INSTALL_PREFIX
    # Just verify it worked
    if [ ! -d "$out" ]; then
      echo "ERROR: CMake workflow did not install to $out"
      exit 1
    fi

    runHook postInstall
  '';

  # Disable standard cmake configure
  dontUseCmakeConfigure = true;
})
```

## Use Cases and Examples

### Example 1: Simple Library

```nix
cmake2nix.lib.buildCMakePackage {
  pname = "mylib";
  version = "1.0.0";
  src = ./.;

  # Just specify toolchain - CMake does the rest
  toolchainFile = cmake2nix.lib.generateToolchain {
    inherit stdenv;
  };
}
```

The entire build is:
```bash
cmake --workflow --preset nix-build
```

### Example 2: With Dependencies

```nix
cmake2nix.lib.buildCMakePackage {
  pname = "myapp";
  version = "2.0.0";
  src = ./.;

  toolchainFile = cmake2nix.lib.generateToolchain {
    inherit stdenv;
  };

  dependencies = {
    fmt = fmt;
    spdlog = spdlog;
    boost = boost;
  };

  # These become CMake cache variables
  cmakeFlags = {
    BUILD_TESTING = false;
    ENABLE_IPO = true;
  };
}
```

### Example 3: Multi-Configuration

```nix
let
  # Common build function
  buildConfig = config: cmake2nix.lib.buildCMakePackage {
    pname = "myapp-${config}";
    src = ./.;

    preset = "nix-${config}";

    cmakeFlags = {
      CMAKE_BUILD_TYPE = lib.toUpper config;
    };
  };
in {
  debug = buildConfig "debug";
  release = buildConfig "release";
  relWithDebInfo = buildConfig "relwithdebinfo";
}
```

### Example 4: Cross-Compilation

```nix
# Cross-compile for aarch64
cmake2nix.lib.buildCMakePackage {
  pname = "myapp";
  src = ./.;

  # Toolchain file handles all cross-compilation setup
  toolchainFile = cmake2nix.lib.generateToolchain {
    stdenv = pkgsCross.aarch64-multiplatform.stdenv;
  };

  # CMake automatically uses the right compilers/tools
  # No manual CC/CXX/AR/etc environment variables!
}
```

## Implementation Roadmap

### Phase 1: Proof of Concept (1 week)
- [ ] Implement basic CMake-as-builder for simple packages
- [ ] Test with pure C/C++ libraries (no complex dependencies)
- [ ] Validate that `cmake -E tar` can extract Nix sources
- [ ] Document limitations and edge cases

### Phase 2: Hybrid Builder (2 weeks)
- [ ] Implement hybrid approach (bash unpack, CMake workflow)
- [ ] Generate CMakePresets.json from Nix configuration
- [ ] Test with real-world packages (fmt, spdlog, etc.)
- [ ] Handle common patterns (tests, docs, examples)

### Phase 3: Workflow Preset Generation (2 weeks)
- [ ] Smart preset generation based on package features
- [ ] Support for multi-configuration builds
- [ ] Custom workflow steps (pre/post hooks in CMake)
- [ ] Integration with lock file system

### Phase 4: Pure CMake Builder (3 weeks)
- [ ] Implement source extraction via cmake -E
- [ ] Handle patching (may need minimal bash wrapper)
- [ ] Environment setup purely through CMake
- [ ] Cross-compilation support

### Phase 5: Advanced Features (4 weeks)
- [ ] CPack integration for package generation
- [ ] CTest integration for testing
- [ ] Multi-output support (dev, doc, man, etc.)
- [ ] Incremental builds (CMake cache in Nix store?)

## Technical Challenges

### 1. Source Preparation

**Challenge:** Nix needs to patch shebangs, fix hardcoded paths, etc.

**Solutions:**
- **Option A:** Minimal bash wrapper for patching, then hand off to CMake
- **Option B:** CMake scripts for common patching operations
- **Option C:** Two-stage derivation (prepare → build)

**Recommended:** Option A (hybrid) for pragmatism.

### 2. Environment Setup

**Challenge:** Need to set up `PATH`, library paths, pkg-config paths, etc.

**Solutions:**
- Encode everything in toolchain file
- Use CMake presets environment variables
- Generate wrapper scripts via CMake

**Recommended:** Toolchain file + presets environment.

### 3. Hooks and Customization

**Challenge:** Users need pre/post build hooks for custom steps.

**Solutions:**
```cmake
# CMake-native hooks via custom targets
add_custom_target(preBuild
  COMMAND ${CMAKE_COMMAND} -E echo "Running pre-build steps"
  # ... custom commands ...
)

add_dependencies(main_target preBuild)
```

Or workflow presets with multiple steps:
```json
{
  "workflowPresets": [{
    "name": "nix-build",
    "steps": [
      {"type": "configure", "name": "nix-build"},
      {"type": "build", "name": "pre-build-hook"},
      {"type": "build", "name": "nix-build"},
      {"type": "build", "name": "post-build-hook"}
    ]
  }]
}
```

### 4. Incremental Builds

**Challenge:** Nix builds are typically one-shot, but CMake benefits from incremental builds.

**Possible Future:**
- Store CMake cache in separate derivation
- Reference previous build's cache
- Only rebuild if inputs changed

**Not a priority:** Get basic builds working first.

### 5. Multi-Output Packages

**Challenge:** Nix packages often have multiple outputs (out, dev, doc, man, lib).

**Solution:** CMake components:
```cmake
install(TARGETS mylib
  ARCHIVE DESTINATION $ENV{lib}/lib
  LIBRARY DESTINATION $ENV{lib}/lib
  RUNTIME DESTINATION $ENV{out}/bin
  INCLUDES DESTINATION $ENV{dev}/include
)

install(FILES ${DOCS}
  DESTINATION $ENV{doc}/share/doc
)
```

## Benefits Summary

### 1. Conceptual Purity
- CMake is the build system → CMake drives the build
- "The dog wags the tail, not vice versa"
- Aligns with pure toolchain philosophy

### 2. Platform Independence
- `cmake -E` commands work everywhere
- No bash-specific idioms
- Cross-platform by design

### 3. Declarative Workflows
- JSON presets are explicit
- No hidden hook ordering
- Easy to understand and debug

### 4. Better CMake Integration
- Leverage CMake's full feature set
- Presets, workflows, CPack, CTest
- Modern CMake best practices

### 5. Reduced Complexity
- Fewer layers of abstraction
- No stdenv "magic"
- Simpler mental model

## Comparison with Other Build Systems

### cargo/rustc as Builder

Cargo doesn't support this pattern - it expects to be called by something else.

### go/build as Builder

Go compiler could theoretically be builder, but Go doesn't have "workflow" concept like CMake.

### Meson/Ninja as Builder

Meson generates ninja files, but ninja is the actual builder. Similar two-step process.

**CMake is unique** in having:
1. Workflow orchestration (presets)
2. Platform-independent commands (cmake -E)
3. Full build lifecycle (configure, build, test, package, install)

This makes it **ideal** as a Nix builder.

## Related Work

### Bazel-in-Nix

Bazel can be a builder, but it has its own sandboxing that conflicts with Nix. CMake doesn't have this issue.

### CMake + Nix in Other Projects

Most projects use bash-driven builds with CMake as a tool. This is the opposite approach.

### CMAKE_INSTALL_PREFIX

The key insight is that CMake **already knows how to install**. We just point it at `$out`:

```cmake
# In generated preset
"cacheVariables": {
  "CMAKE_INSTALL_PREFIX": "$env{out}"
}
```

Then `cmake --build . --target install` puts everything in the right place.

## Future Possibilities

### 1. CMake-Generated Derivations

CMake could **generate its own Nix derivation**:

```cmake
# In CMakeLists.txt
nix_export_derivation(
  PNAME myapp
  VERSION ${PROJECT_VERSION}
  DEPENDENCIES fmt spdlog
)
```

Generates `default.nix` automatically.

### 2. Nix-Aware CMake Modules

```cmake
find_package(Nix REQUIRED)

nix_add_dependency(fmt 10.2.1)
nix_add_dependency(spdlog 1.13.0)

# CMake queries Nix for dependencies!
```

### 3. Lock File Generation via CMake

CMake could introspect its own dependencies and generate lock file:

```bash
cmake --preset nix-build --export-lock-file cmake-lock.nix
```

### 4. Pure CMake Toolchain Auto-Generation

```cmake
# CMake detects Nix environment and generates its own toolchain
if(DEFINED ENV{NIX_CC})
  set(CMAKE_C_COMPILER "$ENV{NIX_CC}/bin/cc")
  set(CMAKE_CXX_COMPILER "$ENV{NIX_CC}/bin/c++")
  # ... etc
endif()
```

## Conclusion

Using CMake as the builder is:

1. **Technically Feasible** - `cmake -E` provides all necessary tools
2. **Philosophically Aligned** - Pure toolchain, build system drives build
3. **Practically Valuable** - Simpler, more declarative, better CMake integration
4. **Future-Proof** - Workflow presets are modern CMake best practice

**Recommendation:** Implement hybrid approach (Phase 2) first for pragmatism, then explore pure CMake builder (Phase 4) as advanced feature.

The key insight: **CMake already knows how to build, test, and install. Let it do its job.**

## Next Steps

1. ✅ Document the vision (this file)
2. ⏭️ Prototype hybrid builder with simple package
3. ⏭️ Test with real-world projects
4. ⏭️ Iterate based on feedback
5. ⏭️ Eventually explore pure CMake builder

When ready, we can start with a simple proof-of-concept using the hybrid approach.
