{ lib }:

let
  # Generate cmake-packages.nix content from lock file
  generatePackagesNix = lock:
    let
      # Extract unique fetcher types needed
      fetcherTypes = lib.unique (lib.filter (t: t != null) (
        lib.mapAttrsToList (name: dep: dep.method or null) (lock.dependencies or { })
      ));

      # Generate import list
      imports = lib.concatStringsSep "\n, " fetcherTypes;

      # Generate package definitions
      packageDefs = lib.concatStringsSep "\n\n  " (lib.mapAttrsToList
        (name: dep: ''
          ${name} = {
            name = "${name}";
            version = "${dep.version or "unknown"}";
            src = ${dep.method or "null"} ${generateFetcherArgs dep.args or {}};
          };''
        )
        (lock.dependencies or { }));

    in
    ''
      # Generated by cmake2nix
      # Do not edit this file manually
      { ${imports}
      }:

      {
        ${packageDefs}
      }
    '';

  # Generate fetcher arguments
  generateFetcherArgs = args:
    let
      argLines = lib.mapAttrsToList
        (key: value:
          if builtins.isString value then
            "  ${key} = \"${value}\";"
          else
            "  ${key} = ${toString value};"
        )
        args;
    in
    ''
      {
      ${lib.concatStringsSep "\n" argLines}
      }'';

  # Generate cmake-env.nix content
  generateEnvNix = { nixCmakePath ? "<nix-cmake>" }:
    ''
      # Generated by cmake2nix
      # Build environment for nix-cmake projects
      { lib
      , pkgs
      , stdenv
      , cmake
      , ninja
      , git
      , makeBinaryWrapper
      }:

      let
        # Import nix-cmake library
        nix-cmake = import ${nixCmakePath} { inherit lib; };

        # Import builders
        builders = nix-cmake.builders pkgs;

      in

      rec {
        # Expose buildCMakePackage for use in default.nix
        inherit (builders) buildCMakePackage;

        # Helper to create FetchContent environment variables
        mkFetchContentEnv = deps:
          lib.concatStringsSep "\n" (lib.mapAttrsToList (name: dep:
            "export FETCHCONTENT_SOURCE_DIR_''${lib.toUpper name}=''${dep.src}"
          ) deps);
      }
    '';

  # Generate default.nix content
  generateDefaultNix = { pname, version, src ? "./." }:
    ''
      # Generated by cmake2nix
      { pkgs ? import <nixpkgs> { }
      , system ? builtins.currentSystem
      }:

      let
        # Import dependencies
        cmakeDeps = pkgs.callPackage ./cmake-packages.nix { };

        # Import build environment
        cmakeEnv = pkgs.callPackage ./cmake-env.nix { inherit pkgs; };

      in

      rec {
        # The main package
        package = cmakeEnv.buildCMakePackage {
          pname = "${pname}";
          version = "${version}";
          src = ${src};

          # Auto-inject dependencies from lock file
          fetchContentDeps = cmakeDeps;
        };

        # Expose individual dependencies for overrides
        deps = cmakeDeps;

        # Development shell
        shell = pkgs.mkShell {
          nativeBuildInputs = [
            pkgs.cmake
            pkgs.ninja
            pkgs.git
          ];

          shellHook = cmakeEnv.mkFetchContentEnv cmakeDeps;
        };
      }
    '';

  # Parse CMakeLists.txt to extract project name and version
  parseCMakeLists = cmakeListsPath:
    let
      content = builtins.readFile cmakeListsPath;

      # Extract project() call
      projectMatch = builtins.match ".*project\\(([^)]+)\\).*" content;

      # Simple extraction - parse project(name VERSION x.y.z)
      projectParts =
        if projectMatch != null then
          lib.splitString " " (lib.head projectMatch)
        else
          [ ];

      pname =
        if builtins.length projectParts > 0 then
          lib.head projectParts
        else
          "cmake-project";

      # Try to find VERSION keyword
      versionMatch = builtins.match ".*VERSION[ \t]+([0-9.]+).*" (lib.head projectMatch or "");
      version =
        if versionMatch != null then
          lib.head versionMatch
        else
          "0.1.0";

    in
    {
      inherit pname version;
    };

in

{
  inherit
    generatePackagesNix
    generateEnvNix
    generateDefaultNix
    parseCMakeLists;
}
