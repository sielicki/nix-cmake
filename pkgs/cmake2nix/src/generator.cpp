#include "cmake2nix.hpp"

#include <fmt/format.h>
#include <fstream>
#include <set>
#include <sstream>

namespace cmake2nix::generator {

std::string generate_packages_nix(const LockFile& lock) {
    std::ostringstream oss;

    // Collect unique fetcher methods
    std::set<std::string> methods;
    for (const auto& [name, dep] : lock.dependencies) {
        if (!dep.method.empty()) {
            methods.insert(dep.method);
        }
    }

    // Header with imports
    oss << "# Generated by cmake2nix\n";
    oss << "# Do not edit this file manually\n";
    oss << "{\n";
    for (const auto& method : methods) {
        oss << ", " << method << "\n";
    }
    oss << "}:\n\n";

    // Dependencies
    oss << "{\n";
    for (const auto& [name, dep] : lock.dependencies) {
        oss << "  " << name << " = {\n";
        oss << "    name = \"" << dep.name << "\";\n";
        oss << "    version = \"" << dep.version << "\";\n";
        oss << "    src = " << dep.method << " {\n";

        // Generate args
        for (const auto& [key, value] : dep.args.items()) {
            if (value.is_string()) {
                oss << "      " << key << " = \"" << value.get<std::string>() << "\";\n";
            } else if (value.is_number()) {
                oss << "      " << key << " = " << value << ";\n";
            } else if (value.is_boolean()) {
                oss << "      " << key << " = " << (value.get<bool>() ? "true" : "false") << ";\n";
            }
        }

        oss << "    };\n";
        oss << "  };\n\n";
    }
    oss << "}\n";

    return oss.str();
}

std::string generate_env_nix(const std::string& nix_cmake_path) {
    return fmt::format(R"(# Generated by cmake2nix
# Build environment for nix-cmake projects
{{ lib
, pkgs
, stdenv
, cmake
, ninja
, git
, makeBinaryWrapper
}}:

let
  # Import nix-cmake library
  nix-cmake = import {} {{ inherit lib; }};

  # Import builders
  builders = nix-cmake.builders pkgs;

in

rec {{
  # Expose buildCMakePackage for use in default.nix
  inherit (builders) buildCMakePackage;

  # Helper to create FetchContent environment variables
  mkFetchContentEnv = deps:
    lib.concatStringsSep "\n" (lib.mapAttrsToList (name: dep:
      "export FETCHCONTENT_SOURCE_DIR_${{lib.toUpper name}}=${{dep.src}}"
    ) deps);
}}
)",
                       nix_cmake_path);
}

std::string generate_default_nix(const ProjectInfo& info) {
    return fmt::format(R"(# Generated by cmake2nix
{{ pkgs ? import <nixpkgs> {{ }}
, system ? builtins.currentSystem
}}:

let
  # Import dependencies
  cmakeDeps = pkgs.callPackage ./cmake-packages.nix {{ }};

  # Import build environment
  cmakeEnv = pkgs.callPackage ./cmake-env.nix {{ inherit pkgs; }};

in

rec {{
  # The main package
  package = cmakeEnv.buildCMakePackage {{
    pname = "{}";
    version = "{}";
    src = ./.;

    # Auto-inject dependencies from lock file
    fetchContentDeps = cmakeDeps;
  }};

  # Expose individual dependencies for overrides
  deps = cmakeDeps;

  # Development shell
  shell = pkgs.mkShell {{
    nativeBuildInputs = [
      pkgs.cmake
      pkgs.ninja
      pkgs.git
    ];

    shellHook = cmakeEnv.mkFetchContentEnv cmakeDeps;
  }};
}}
)",
                       info.pname, info.version);
}

void write_all(const Config& config, const LockFile& lock, const ProjectInfo& info) {
    fs::create_directories(config.output_dir);

    // Generate and write cmake-packages.nix
    {
        auto path = config.output_dir / config.packages_nix;
        std::ofstream file(path);
        if (!file) {
            throw std::runtime_error("Failed to write " + path.string());
        }
        file << generate_packages_nix(lock);
        fmt::print("cmake2nix: Generated {}\n", path.string());
    }

    // Generate and write cmake-env.nix
    {
        auto path = config.output_dir / config.env_nix;
        std::ofstream file(path);
        if (!file) {
            throw std::runtime_error("Failed to write " + path.string());
        }
        file << generate_env_nix("<nix-cmake>");
        fmt::print("cmake2nix: Generated {}\n", path.string());
    }

    // Generate and write default.nix
    {
        auto path = config.output_dir / config.composition_nix;
        std::ofstream file(path);
        if (!file) {
            throw std::runtime_error("Failed to write " + path.string());
        }
        file << generate_default_nix(info);
        fmt::print("cmake2nix: Generated {}\n", path.string());
    }

    fmt::print("\ncmake2nix: âœ“ Generation complete\n");
    fmt::print("Usage:\n");
    fmt::print("  nix-build -A package       # Build the project\n");
    fmt::print("  nix-shell -A shell         # Enter development shell\n");
}

} // namespace cmake2nix::generator
